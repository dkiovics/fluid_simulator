#version 460 core
#extension GL_NV_shader_atomic_float : enable
precision highp float;

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

uniform ivec2 screenSize;
uniform float depthErrorScale;

uniform sampler2D referenceImage;
uniform sampler2D plusPertImage;
uniform sampler2D minusPertImage;

struct FragmentParam {
	int paramNum;
	int paramIndexes[40];
};

struct FragmentParam {
	int paramNum;
	int paramIndexes[40];
};

layout(std430, binding = 0) restrict readonly buffer paramNegativeOffsetsSSBO {
	float paramNegativeOffsets[];
};

layout(std430, binding = 1) restrict readonly buffer paramPositiveOffsetsSSBO {
	float paramPositiveOffsets[];
};

layout(std430, binding = 2) restrict readonly buffer pixelParamsSSBO {
	FragmentParam pixelParams[];
};

layout(std430, binding = 3) restrict buffer gradientSSBO {
	float gradient[];
};

uniform struct{
    mat4 viewMatrix;
	mat4 viewMatrixInverse;
	mat4 projectionMatrix;
	mat4 projectionMatrixInverse;
    vec4 position;
} camera;

vec3 uvToEye(vec2 texCoord, float depth) {
	vec4 ndc = vec4(texCoord * 2.0 - 1.0, depth * 2.0 - 1.0, 1.0);
	vec4 eyeSpacePos = camera.projectionMatrixInverse * ndc;
	return eyeSpacePos.xyz / eyeSpacePos.w;
}


void main(void) {
	ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
	vec2 texCoord = vec2(pos) / vec2(screenSize) + 0.5 / vec2(screenSize);

	float referenceDepth = texelFetch(referenceImage, pos, 0).r;
	float plusPertDepth = texelFetch(plusPertImage, pos, 0).r;
	float minusPertDepth = texelFetch(minusPertImage, pos, 0).r;

	float positiveError = (uvToEye(texCoord, referenceDepth).z - uvToEye(texCoord, plusPertDepth).z) * depthErrorScale;
	float negativeError = (uvToEye(texCoord, referenceDepth).z - uvToEye(texCoord, minusPertDepth).z) * depthErrorScale;
	positiveError = positiveError * positiveError;
	negativeError = negativeError * negativeError;

	int index = pos.y * screenSize.x + pos.x;
	FragmentParam contributingParam = pixelParams[index];

	for(int p = 0; p < contributingParam.paramNum; p++)
	{
		int contributingParamIndex = contributingParam.paramIndexes[p];
		int offset = contributingParamIndex * 4;

		vec4 positiveOffset = vec4(paramPositiveOffsets[offset], paramPositiveOffsets[offset + 1], paramPositiveOffsets[offset + 2], paramPositiveOffsets[offset + 3]);
		vec4 negativeOffset = vec4(paramNegativeOffsets[offset], paramNegativeOffsets[offset + 1], paramNegativeOffsets[offset + 2], paramNegativeOffsets[offset + 3]);

		vec4 signedPerturbation = positiveOffset - negativeOffset;

		if(signedPerturbation.x != 0.0)
			atomicAdd(gradient[offset], (positiveError - negativeError) / signedPerturbation.x);
		if(signedPerturbation.y != 0.0)
			atomicAdd(gradient[offset + 1], (positiveError - negativeError) / signedPerturbation.y);
		if(signedPerturbation.z != 0.0)
			atomicAdd(gradient[offset + 2], (positiveError - negativeError) / signedPerturbation.z);
		if(signedPerturbation.w != 0.0)
			atomicAdd(gradient[offset + 3], (positiveError - negativeError) / signedPerturbation.w);
	}
}